<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="meow">
  
  
  
  <link rel="prev" href="https://ash-z01.github.io/2020/sql002-innodb_storage_structure/" />
  <link rel="next" href="https://ash-z01.github.io/2020/number/" />
  <link rel="canonical" href="https://ash-z01.github.io/2020/essential/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           Essential of Lambda-Calculus | Rubik Cell Space
       
  </title>
  <meta name="title" content="Essential of Lambda-Calculus | Rubik Cell Space">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/ash-z01.github.io\/"
    },
    "articleSection" : "posts",
    "name" : "Essential of Lambda-Calculus",
    "headline" : "Essential of Lambda-Calculus",
    "description" : "法国作家、冒险家、艺术家和航空工程师 安东尼·德·圣埃克苏佩里 (Antoine de Saint-Exupéry) 在论飞机设计时说： “La perfection est atteinte non quand il ne reste rien à ajouter，mais quand il ne reste rien à enlever!” 完美之道，不在无可增加，而在无可删减!\n 0x01 什么是 lambda-calculus λ-演算(lambda\/λ-calculus)是一套从数学逻辑中发展，以变量绑定和替换的规则，来研究函数如何抽象化定义、函数如何被应用以及递归的形式系统.\n20世纪30年代，一个名叫阿隆佐-邱奇的数学家,首次发表了Lambda演算， 从而解决了可计算理论中的判定性问题. lambda演算作为一种广泛用途的计算模型，可以清晰地定义什么是一个可计算函数，而任何可计算函数都能以这种形式表达和求值. 𝜆-演算 分为 `类型化𝜆-演算(Typed λ-Calculus)` 和 `无类型𝜆-演算(Type-Free λ-Calculus)` 也称为 `朴素λ-演算(Naive λ-Calculs)`. lambda演算简单易读写，语义强大同时图灵完备, 后续内容主要针对是无类型的λ-演算展开讲解.\n0x02 一切皆函数 大家都学过不少编程语言, C\u002b\u002b、Java、Go、Python等\u0026hellip; 它们大部分都有着丰富的语法特性，很多特性可以互相替换。 如果我们遵循安东尼的完美之道，去裁剪语法，那么最小化的语言是什么样的呢~\nlambda演算可比拟最根本的编程语言, 它的内核非常小,可以用以下规则来描述:\n   语法\/L-exp 名称 描述     a 变量\/原子 标识符引用就是一个名字，这个名字用于匹配函数表达式中的某个参数名   λx.",
    "inLanguage" : "en-us",
    "author" : "ash",
    "creator" : "ash",
    "publisher": "ash",
    "accountablePerson" : "ash",
    "copyrightHolder" : "ash",
    "copyrightYear" : "2020",
    "datePublished": "2020-11-18 17:10:10 \u002b0800 CST",
    "dateModified" : "2020-11-18 17:10:10 \u002b0800 CST",
    "url" : "https:\/\/ash-z01.github.io\/2020\/essential\/",
    "wordCount" : "371",
    "keywords" : [ "Lambda","λ","λ-演算", "Rubik Cell Space"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch">
                
                🐾
            </a>&nbsp;<a href="https://ash-z01.github.io/">Rubik Cell Space</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch">
                
                🐾
                </a>&nbsp;<a href="https://ash-z01.github.io/">Rubik Cell Space</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Essential of Lambda-Calculus</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://ash-z01.github.io/" rel="author">ash</a> 🐱‍💻 
                <span class="post-time">
                on <time datetime=2020-11-18 itemprop="datePublished">November 18, 2020</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://ash-z01.github.io/categories/lambda%E5%A5%A5%E7%A7%98/"> Lambda奥秘 </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          <blockquote>
<p>法国作家、冒险家、艺术家和航空工程师 <strong>安东尼·德·圣埃克苏佩里</strong> (Antoine de Saint-Exupéry) 在论飞机设计时说：
“La perfection est atteinte non quand il ne reste rien à ajouter，mais quand il ne reste rien à enlever!”
<strong>完美之道，不在无可增加，而在无可删减!</strong></p>
</blockquote>
<h2 id="0x01-什么是-lambda-calculus">0x01 什么是 lambda-calculus</h2>
<p><strong>λ-演算</strong>(lambda/λ-calculus)是一套从数学逻辑中发展，以变量绑定和替换的规则，来研究函数如何抽象化定义、函数如何被应用以及递归的形式系统.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-s" data-lang="s"><span style="color:#ae81ff">20</span>世纪<span style="color:#ae81ff">30</span>年代，一个名叫阿隆佐<span style="color:#f92672">-</span>邱奇的数学家,首次发表了Lambda演算， 从而解决了可计算理论中的判定性问题.
lambda演算作为一种广泛用途的计算模型，可以清晰地定义什么是一个可计算函数，而任何可计算函数都能以这种形式表达和求值.
𝜆<span style="color:#f92672">-</span>演算 分为 `类型化𝜆-演算(Typed λ-Calculus)` 和 `无类型𝜆-演算(Type-Free λ-Calculus)` 也称为 `朴素λ-演算(Naive λ-Calculs)`.
</code></pre></div><p>lambda演算简单易读写，语义强大同时图灵完备, 后续内容主要针对是无类型的λ-演算展开讲解.</p>
<h2 id="0x02-一切皆函数">0x02 一切皆函数</h2>
<p>大家都学过不少编程语言, C++、Java、Go、Python等&hellip; 它们大部分都有着丰富的语法特性，很多特性可以互相替换。
如果我们遵循安东尼的完美之道，去裁剪语法，那么最小化的语言是什么样的呢~</p>
<p>lambda演算可比拟最根本的编程语言, 它的内核非常小,可以用以下规则来描述:</p>
<table>
<thead>
<tr>
<th style="text-align:right">语法/L-exp</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">a</td>
<td>变量/原子</td>
<td>标识符引用就是一个名字，这个名字用于匹配函数表达式中的某个参数名</td>
</tr>
<tr>
<td style="text-align:right">λx.M</td>
<td>抽象化/抽象规则</td>
<td>函数定义, 变量x 在 M 中被绑定</td>
</tr>
<tr>
<td style="text-align:right">(F N)</td>
<td>应用/应用规则</td>
<td>将函数 F 应用于参数 N</td>
</tr>
</tbody>
</table>
<p>上面表格中看着比较抽象，试着写得简明一点..</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-s" data-lang="s"><span style="color:#f92672">&lt;</span>identifier<span style="color:#f92672">&gt;</span> <span style="color:#f92672">--&gt;</span> a <span style="color:#f92672">|</span> b <span style="color:#f92672">|</span> <span style="color:#66d9ef">...</span>   <span style="color:#f92672">//</span> 标识符
<span style="color:#f92672">&lt;</span>abstraction<span style="color:#f92672">&gt;</span> <span style="color:#f92672">--&gt;</span> λ<span style="color:#f92672">&lt;</span>identifier<span style="color:#f92672">&gt;</span>.&lt;λ<span style="color:#f92672">-</span>exp<span style="color:#f92672">&gt;</span>  <span style="color:#f92672">//</span> 抽象规则
<span style="color:#f92672">&lt;</span>application<span style="color:#f92672">&gt;</span> <span style="color:#f92672">--&gt;</span> (<span style="color:#f92672">&lt;</span>λ<span style="color:#f92672">-</span>exp<span style="color:#f92672">&gt;</span>)<span style="color:#f92672">&lt;</span>identifier<span style="color:#f92672">&gt;</span>  <span style="color:#f92672">//</span> 应用规则
<span style="color:#f92672">&lt;</span>λ<span style="color:#f92672">-</span>exp<span style="color:#f92672">&gt;</span> <span style="color:#f92672">--&gt;</span> <span style="color:#f92672">&lt;</span>identifier<span style="color:#f92672">&gt;</span> <span style="color:#f92672">|</span> <span style="color:#f92672">&lt;</span>abstraction<span style="color:#f92672">&gt;</span> <span style="color:#f92672">|</span> <span style="color:#f92672">&lt;</span>application<span style="color:#f92672">&gt;</span>  <span style="color:#f92672">//</span> 所有这些都是 λ表达式
</code></pre></div><h2 id="0x03-柯里化">0x03 柯里化</h2>
<p>观察上面的定义，你会发现一个 Lambda表达式 只接受一个参数, 这似乎是一个很大的局限. (嘛~ 其实我们平时可以写多个参数的λ-exp, 更简洁一点)</p>
<p>比如，怎样才能在只有一个参数的情况下实现加法呢？</p>
<p>当然没有问题~，因为函数也是值嘛. 所以单参数函数可以返回另一个单参数的函数，这样就可以实现两个参数相加的函数了. 本质上二者一致.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-s" data-lang="s">这就是所谓的柯里化(Currying)，以伟大的逻辑学家 Haskell Curry 命名.
</code></pre></div><h2 id="0x04-自由与约束">0x04 自由与约束</h2>
<p>自由变量 是那些在lambda抽象中不受到绑定的变量..</p>
<p>啥意思呢? 继续看..</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-s" data-lang="s">表达式 [lambda x . x] 中的lambda项没有自由变量. 
表达式 [lambda x . y x] 中的lambda项，有一个自由变量 [y].
</code></pre></div><p>这就引出了一个 lambda表达式 的重要语法：闭包(closure)或者叫完全绑定(complete-binding). (接触过一些函数式编程技术的小伙伴一定听说过闭包吧~), 在对一个Lambda表达式进行求值的时候，不能引用任何未绑定的标识符.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-s" data-lang="s">表达式 [lambda y <span style="color:#a6e22e">. </span>(lambda x . plus x y)]

在内层演算 [lambda x . plus x y] 中，[y] 和 [plus] 是自由的，[x]是绑定的, 
而在完整的表达中，[x] 和 [y]是绑定的<span style="color:#f92672">:</span> [x]受内层绑定，而[y]由剩下的演算绑定. [plus]仍然是自由变量.
</code></pre></div><h2 id="0x05-转换与规约">0x05 转换与规约</h2>
<p>lambda表达式的求值过程中，需要用到的一些操作.</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>(λx.M[x]) -&gt; (λy.M[y])</td>
<td>α-转换</td>
<td>重命名表达式中的绑定(形式)变量, 避免名称冲突</td>
</tr>
<tr>
<td>((λx.M) E) -&gt; (M[x:=E])</td>
<td>β-归约</td>
<td>在抽象化的函数定义体中，以参数表达式代替绑定变量</td>
</tr>
</tbody>
</table>
<p>举个栗子.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-s" data-lang="s"><span style="color:#f92672">//</span> 先来看看 alpha<span style="color:#f92672">-</span>转换
lambda x . x  <span style="color:#f92672">---</span> alpha<span style="color:#f92672">-</span>转换 <span style="color:#f92672">---&gt;</span>  lambda z . z

<span style="color:#f92672">//</span> 再来..
lambda f <span style="color:#a6e22e">. </span>(lambda x . f x)   <span style="color:#f92672">---</span> alpha<span style="color:#f92672">-</span>转换 <span style="color:#f92672">---&gt;</span>  lambda f <span style="color:#a6e22e">. </span>(lambda y . f y)

<span style="color:#f92672">//</span> 再瞧瞧 beta<span style="color:#f92672">-</span>规约
(lambda x . f x) <span style="color:#ae81ff">666</span>  <span style="color:#f92672">---</span> beta<span style="color:#f92672">-</span>规约 <span style="color:#f92672">---&gt;</span> f <span style="color:#ae81ff">666</span>

<span style="color:#f92672">//</span> 再来<span style="color:#a6e22e">..
</span><span style="color:#a6e22e"></span>(lambda n <span style="color:#a6e22e">. </span>(lambda x . n f x)) <span style="color:#ae81ff">666</span>  <span style="color:#f92672">---</span> beta<span style="color:#f92672">-</span>规约 <span style="color:#f92672">---&gt;</span> lambda x . 666 f x
</code></pre></div><p>其实lambda还有一种变换操作, 叫做 <code>η-变换(Eta-变换)</code>..</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-s" data-lang="s">Eta<span style="color:#f92672">-</span>变换 表达的是外延性的概念，在这里外延性指的是，对于任一给定的参数，当且仅当两个函数得到的结果都一致，则它们将被视同为一个函数.
Eta<span style="color:#f92672">-</span>变换可以令 [lambda x . f x] 和 [f] 相互转换，只要 [x] 不是 [f] 中的自由变量.
</code></pre></div><h2 id="0x06-能不能通俗点">0x06 能不能通俗点?</h2>
<p>那就来点小栗子吧~</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-s" data-lang="s">lambda x . x  <span style="color:#f92672">//</span> 这个表达式足够简单吧， 入啥出啥， 那应用一下

(lambda x . x) <span style="color:#ae81ff">1</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
(lambda x . x) lambda z . z <span style="color:#f92672">=</span> lambda z . z
</code></pre></div><p>看看下一个..</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-s" data-lang="s">lambda x <span style="color:#a6e22e">. </span>(lambda y . plus x y)  <span style="color:#f92672">//</span> 假定 plus 已经实现了数字相加，具体实现请看下回分解吧<span style="color:#f92672">~</span>

<span style="color:#f92672">//</span> 应用一下

(lambda x <span style="color:#a6e22e">. </span>(lambda y . plus x y)) <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span>
    <span style="color:#f92672">=</span> (lambda y . plus <span style="color:#ae81ff">2</span> y) <span style="color:#ae81ff">3</span>  <span style="color:#f92672">//</span> Beta规约
    <span style="color:#f92672">=</span> plus <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">//</span> Beta<span style="color:#f92672">-</span>规约
    <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span> 
</code></pre></div><h2 id="0x07-参考">0x07 参考</h2>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97">wiki - λ演算</a></li>
<li><a href="http://goodmath.blogspot.com/">blog - Good Math/Bad Math</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E9%9A%86%E4%BD%90%C2%B7%E9%82%B1%E5%A5%87">wiki - 阿隆佐·邱奇</a></li>
<li><a href="https://liujiacai.net/blog/2014/10/12/lambda-calculus-introduction/">blog - Keep Coding</a></li>
</ul>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>meow </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://ash-z01.github.io/2020/essential/>https://ash-z01.github.io/2020/essential/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://ash-z01.github.io/tags/lambda/">
                    #Lambda</a></span>
            
            <span class="tag"><a href="https://ash-z01.github.io/tags/%CE%BB/">
                    #λ</a></span>
            
            <span class="tag"><a href="https://ash-z01.github.io/tags/%CE%BB-%E6%BC%94%E7%AE%97/">
                    #λ-演算</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://ash-z01.github.io/">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://ash-z01.github.io/2020/sql002-innodb_storage_structure/" class="prev" rel="prev" title="InnoDB 存储结构"><i class="iconfont icon-left"></i>&nbsp;InnoDB 存储结构</a>
         
        
        <a href="https://ash-z01.github.io/2020/number/" class="next" rel="next" title="Number of Lambda-Calculus">Number of Lambda-Calculus&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2020 - 2021</span>
        
        <span class="with-ash">
        
        🚀
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://ash-z01.github.io/">meow</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
